
proc mounttest {} {
    send "mounttest\n"
    expect "mounttest tests passed successfully"
    assert_on_exit_status
}

proc mount_bind_test {} {
    send "mkdir bind_tests\n"
    send "cd bind_tests\n"
    sleep 0.5

    #one file in dir
    send "mkdir d1 d2\n"
    sleep 0.5
    send "echo test > d2/somefile\n"
    sleep 0.5
    send "mount -t bind d1 d2\n"
    sleep 0.5
    send "cat d1/somefile\n"
    expect "test"
    sleep 0.5
    send "umount d1\n"
    sleep 0.5

    #rm file in dir
    send "mkdir d3 d4\n"
    sleep 0.5
    send "echo test > d4/somefile\n"
    sleep 0.5
    send "mount -t bind d3 d4\n"
    sleep 0.5
    send "rm d3/somefile\n"
    sleep 0.5
    send "cat d4/somefile\n"
    expect "cat: cannot open d4/somefile"
    sleep 0.5
    send "umount d3\n"
    sleep 0.5

    #mount root dir
    send "mkdir d5\n"
    sleep 0.5
    send "mount -t bind / d5\n"
    sleep 0.5
    expect "Can't mount root directory"
    send "mount -t bind d5 /\n"
    sleep 0.5
    send "echo test > d5/somefile\n"
    sleep 0.5
    send "cat /somefile\n"
    expect "test"
    sleep 0.5
    send "umount d5\n"
    sleep 0.5

    #mount file
    send "mkdir d6\n"
    sleep 0.5
    send "echo test > somefile\n"
    sleep 0.5
    send "mount -t bind somefile d6\n"
    expect "mount point is not a directory"
    sleep 0.5

    send "cd ..\n"
    sleep 0.5

    #clean
    send "rm -r bind_tests\n"
    assert_on_exit_status
}

proc umount_bind_mount_test {} {
    send "mkdir orig\n"
    assert_on_exit_status
    send "echo test > orig/tfile\n"
    assert_on_exit_status
    send "mkdir bind_f\n"
    assert_on_exit_status
    send "mount -t bind bind_f orig\n"
    assert_on_exit_status
    send "cat bind_f/tfile\n"
    expect "test"

    send "umount bind_f\n"
    assert_on_exit_status
    send "cat bind_f/tfile\n"
    expect "cat: cannot open bind_f/tfile"

    #clean
    send "rm -r orig bind_f\n"
    assert_on_exit_status
}


# Test the 'rm' userspace utility with recursive flag
proc rm_recursive_test {} {
    set depth 10
    set initial_path "/d1"
    set path "/"
    for {set i 1} {$i <= $depth} {incr i} {
        append path "/d${i}"
        send "mkdir $path\n"
        assert_on_exit_status
    }

    send "echo helloworld > $path/file.txt\n"
    assert_on_exit_status

    send "rm $initial_path\n"
    expect "cannot unlink $initial_path"

    send "cat $path/file.txt\n"
    expect "helloworld"

    send "rm -r $initial_path\n"
    assert_on_exit_status

    send "cat $path/file.txt\n"
    expect "cat: cannot open $path/file.txt"
}

# - ioctl syscall tests
# - for details: ioctltests.c
proc ioctl_syscall_test {} {
    send "ioctltests\n"
    assert_on_exit_status
}

proc cp_copy_dir_test {} {
    #one file in dir
    send "mkdir d1\n"
    sleep 0.5
    send "echo test > d1/f1\n"
    sleep 0.5
    send "mkdir d2\n"
    sleep 0.5
    send "cp d1 d2\n"
    sleep 0.5
    send "cat d2/f1\n"
    expect "test"
    sleep 0.5

    #recursive dir test
    send "mkdir d3\n"
    sleep 0.5
    send "mkdir d3/d4\n"
    sleep 0.5
    send "echo test > d3/d4/f1\n"
    sleep 0.5
    send "mkdir t1\n"
    sleep 0.5
    send "cp d3 t1\n"
    sleep 0.5
    send "cat t1/d4/f1\n"
    expect "test"
    sleep 0.5

    #dir in root dir, extra slash
    send "mkdir /a /b\n"
    sleep 0.5
    send "echo test > /a/c\n"
    sleep 0.5
    send "cp /a /b/\n"
    sleep 0.5
    send "cat /b/c\n"
    sleep 0.5
    expect "test"

    #clean
    send "rm -r d1 d2 d3 t1 a b\n"
    assert_on_exit_status
}

proc cp_copy_file_test {} {

    #bad args test
    send "cp f1\n"
    expect "cp requires two arguments: source and target"
    sleep 0.5

    #source file doesn't exist
    send "cp f1 f2\n"
    expect "can't locate f1"
    sleep 0.5

    #target dir doesn't exist
    send "echo test > f1\n"
    sleep 0.5
    send "cp f1 d1/f1\n"
    expect "can't create d1/f1, make sure the entire path exists"

    #test single file
    sleep 0.5
    send "cp f1 f2\n"
    sleep 0.5
    send "cat f2\n"
    expect "test"
    sleep 0.5

    #clean
    send "rm -r f1 f2\n"
    assert_on_exit_status
}


proc command_exit_status_test {} {
    # Test cd
    send "cd baddirname_itdoesntexist\n"
    expect "$ "
    sleep 1
    send "echo $?\n"
    sleep 1
    expect -re "\\n-2"

    # Test exec
    send "thereisnosuchcommand\n"
    expect "$ "
    sleep 1
    send "echo $?\n"
    sleep 1
    expect -re "\\n1"
}
