proc pouch_basic_tests { } {
    prepare_pouch_images

    # set running [pouch_start_test]
    start_container "1" "Pouch: c1 starting" "img_a"
    pid_check "PID: 2"


    # set running [pouch_connect_test]

    connect_container "1"
    pid_check "PID: 1"

    # set running [pouch_binaries_test]

    send "echo test > testfile\n"
    assert_on_exit_status

    send "cat testfile\n"
    sleep 0.5
    expect "test"
    expect "$ "

    # set running [pouch_disconnect_test]

    disconnect_container
    pid_check "PID: 2"

    # set running [pouch_destroy_test]
    send "ls pconf/c1\n"
    expect -re {c1\s+2\s+[0-9]+\s+[0-9]+}
    destroy_container "1" "Pouch: c1 destroyed"

    send "ls pconf/c1\n"
    expect "ls: cannot open pconf/c1"
}

# - Stress test
# - scenarios that may lead to pouch operations failures
proc pouch_stress_test {} {
    for {set x 0} {$x < 10} {incr x} {
        set running [start_container "1" "Pouch: c1 starting" "img_a"]
        sleep 0.5
        set running [destroy_container "1" "Pouch: c1 destroyed"]
        sleep 0.5
    }
}

# - Cgroup already exists test:
# - check that container is not created if cgroup with give container's name already exists
proc pouch_cgroup_already_exists { } {
    prepare_pouch_images
    send "mkdir /cgroup/c5\n"
    assert_on_exit_status
    set running [start_container "5" "cgroup already exists" "img_a" 1]
}

# - Test tries to create 4 containers, in the last one we are expecting:
# - 'Cannot find tty' because there are only 3 containers available
proc pouch_to_many_cnts_test { } {
    prepare_pouch_images
    set running [start_container "1" "Pouch: c1 starting" "img_a"]
    set running [start_container "2" "Pouch: c2 starting" "img_b"]
    set running [start_container "3" "Pouch: c3 starting" "img_c"]
    set running [start_container "4" "Pouch: cannot create more containers" "img_a" 1]

    set running [destroy_container "1" "Pouch: c1 destroyed"]
    set running [destroy_container "2" "Pouch: c2 destroyed"]
    set running [destroy_container "3" "Pouch: c3 destroyed"]
}


# - Display containers list, inside and outside of container
proc pouch_list_test { } {
    prepare_pouch_images
    set running [start_container "1" "Pouch: c1 starting" "img_a"]
    set running [start_container "2" "Pouch: c2 starting" "img_b"]
    set running [start_container "3" "Pouch: c3 starting" "img_c"]

    send "pouch list\n"
    expect "Pouch containers:"
    expect "1. c1 : started"
    expect "2. c2 : started"
    expect "3. c3 : started"

    set running [connect_container "1"]
    send "\n"

    send "pouch list\n"
    assert_on_exit_status 1

    set running [disconnect_container]
}


# - Limit cgroup test:
proc pouch_cgroup_limit_test { } {
    prepare_pouch_images
    set running [start_container "1" "Pouch: c1 starting" "img_a"]

    sleep 1
    send "pouch cgroup c1 cpu.max 10000,20000\n"

    expect {
       "Pouch: c1 cgroup applied"
    }

    send "cat /cgroup/c1/cpu.max\n"

    expect {
       -re ".*max - 10000.*period - 20000.*"
    }
}

# - Disconnect outside:
# - test error message in this scenario
# - if running pouch 'disconnect outside' - print help for outside commands
# - if giving a wrong cname outside - respond with correct error message
proc pouch_disconnect_outside_container_test { } {

    #check we are outside
    set running [pid_check "PID: 2"]

    send "pouch disconnect c6\n"
    expect {
       "Error: command disconnect not allowed in outside container."
    }

    assert_on_exit_status 1

    send "pouch disconnect\n"
    expect {
       "Error: command disconnect not allowed in outside container."
    }

    assert_on_exit_status 1
}

# - Pouch info test:
# - test error messages in different scenarios
# - if running pouch info outside - should print help for outside commands
# - if giving a wrong cname - should respond with correct error message
proc pouch_info_container_test { } {

    #check we are outside - epxects argument
    set running [pid_check "PID: 2"]
    send "pouch info\n"
    expect {
        "Error: Invalid number of arguments."
    }
    assert_on_exit_status 1

    # now no container exists
    sleep 2
    send "pouch info c6\n"
    expect "Pouch: c6 container not found"
}

proc test_pouch_builds {} {
    run_test     test_pouch_build_file_parsing Valid1.Pouchfile
    run_test     test_pouch_build_file_parsing Valid2.Pouchfile
    run_test     test_pouch_build_file_parsing Valid3.Pouchfile
    run_test     test_pouch_build_file_parsing Valid4.Pouchfile
}

proc test_internal_images { } {
    # For each one of internal_fs_[a,b,c], mount it, check if it is mounted, unmount it, check if it is unmounted.
    set internal_images [list a b c]
    foreach elem $internal_images {
        send "mkdir /m$elem\n"
        assert_on_exit_status
        send "mount internal_fs_$elem /m$elem\n"
        assert_on_exit_status
        send "ls /m$elem\n"
        send "umount /m$elem\n"
        assert_on_exit_status
    }
}