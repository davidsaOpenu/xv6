proc pouch_basic_tests { } {
    set running [pouch_start_test]
    set running [pouch_connect_test]
    set running [pouch_binaries_test]
    set running [pouch_disconnect_test]
    set running [pouch_destroy_test]
}

# - Stress test
# - scenarios that may lead to pouch operations failures
proc pouch_stress_test {} {
    for {set x 0} {$x < 10} {incr x} {
        set running [start_container "1" "Pouch: c1 starting" "img_a"]
        sleep 0.5
        set running [destroy_container "1" "Pouch: c1 destroyed"]
        sleep 0.5
    }
}

# - Cgroup already exists test:
# - check that container is not created if cgroup with give container's name already exists
proc pouch_cgroup_already_exists { } {
    send "mkdir /cgroup/c5\n"
    assert_on_exit_status
    set running [start_container "5" "cgroup already exists" "img_a" 1]
}

# - Test tries to create 4 containers, in the last one we are expecting:
# - 'Cannot find tty' because there are only 3 containers available
proc pouch_to_many_cnts_test { } {
    set running [start_container "1" "Pouch: c1 starting" "img_a"]
    set running [start_container "2" "Pouch: c2 starting" "img_b"]
    set running [start_container "3" "Pouch: c3 starting" "img_c"]
    set running [start_container "4" "Pouch: cannot create more containers" "img_a" 1]
}

proc pouch_to_many_cnts_test_remove { } {
    set running [destroy_container "1" "Pouch: c1 destroyed"]
    set running [destroy_container "2" "Pouch: c2 destroyed"]
    set running [destroy_container "3" "Pouch: c3 destroyed"]
}


# - Display containers list, inside and outside of container
proc pouch_list_test { } {

    #this test assumes there are 3 started containers
    send "pouch list\n"
    expect "Pouch containers:"
    expect "1. c1 : started"
    expect "2. c2 : started"
    expect "3. c3 : started"

    set running [connect_container "1"]
    send "\n"

    send "pouch list\n"
    assert_on_exit_status 1

    set running [disconnect_container]
}


# - Limit cgroup test:
proc pouch_cgroup_limit_test { } {
    sleep 1
    send "pouch cgroup c1 cpu.max 10000,20000\n"

    expect {
       "Pouch: c1 cgroup applied"
    }

    send "cat /cgroup/c1/cpu.max\n"

    expect {
       -re ".*max - 10000.*period - 20000.*"
    }
}

# - Disconnect outside:
# - test error message in this scenario
# - if running pouch 'disconnect outside' - print help for outside commands
# - if giving a wrong cname outside - respond with correct error message
proc pouch_disconnect_outside_container_test { } {

    #check we are outside
    set running [pid_check "PID: 2"]

    send "pouch disconnect c6\n"
    expect {
       "Error: command disconnect not allowed in outside container."
    }

    assert_on_exit_status 1

    send "pouch disconnect\n"
    expect {
       "Error: command disconnect not allowed in outside container."
    }

    assert_on_exit_status 1
}

# - Pouch info test:
# - test error messages in different scenarios
# - if running pouch info outside - should print help for outside commands
# - if giving a wrong cname - should respond with correct error message
proc pouch_info_container_test { } {

    #check we are outside - epxects argument
    set running [pid_check "PID: 2"]
    send "pouch info\n"
    expect {
        "Error: Invalid number of arguments."
    }
    assert_on_exit_status 1

    # now no container exists
    sleep 2
    send "pouch info c6\n"
    expect "Pouch: c6 container not found"
}

proc test_all_pouch_build { } {
    # At this stage, no images are installed on the system.
    set running [test_pouch_build_valid_args]
    set running [test_pouch_build_invalid_args]
    set running [prepare_pouch_images]
    # create fileX.txt from 1 to 5:
    for {set i 1} {$i <= 5} {incr i} {
        send "echo hi$i > file$i.txt\n"
        assert_on_exit_status
    }
    set running [test_pouch_build_file_parsing]
    # Remove all files created
    for {set i 1} {$i <= 5} {incr i} {
        send "rm file$i.txt\n"
        assert_on_exit_status
    }
    set running [remove_pouch_images]
}


proc test_internal_images { } {
    # For each one of internal_fs_[a,b,c], mount it, check if it is mounted, unmount it, check if it is unmounted.
    set internal_images [list a b c]
    foreach elem $internal_images {
        send "mkdir /m$elem\n"
        assert_on_exit_status
        send "mount internal_fs_$elem /m$elem\n"
        assert_on_exit_status
        send "ls /m$elem\n"
        send "umount /m$elem\n"
        assert_on_exit_status
    }
}